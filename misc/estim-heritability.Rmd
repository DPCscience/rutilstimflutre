---
title: "Estimating heritability"
author: "Timothée Flutre (INRA)"
date: "`r format(Sys.time(), '%d/%m/%Y %H:%M:%S')`"
colorlinks: true
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: TRUE
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: TRUE
urlcolor: blue
---

<!--
This R chunk is used to set up some options.
-->
```{r setup, include=FALSE}
R.v.maj <- as.numeric(R.version$major)
R.v.min.1 <- as.numeric(strsplit(R.version$minor, "\\.")[[1]][1])
if(R.v.maj < 2 || (R.v.maj == 2 && R.v.min.1 < 15))
  stop("requires R >= 2.15", call.=FALSE)

suppressPackageStartupMessages(library(knitr))
opts_chunk$set(echo=TRUE, warning=TRUE, message=TRUE, cache=FALSE, fig.align="center")
```


# Overview

This document aims at estimating heritability (borad or narrow sense).

This document requires external packages to be available:
```{r load_pkg}
suppressPackageStartupMessages(library(mvtnorm)) # on the CRAN
suppressPackageStartupMessages(library(lme4)) # on the CRAN
suppressPackageStartupMessages(library(INLA)) # online
```

This R chunk is used to assess how much time it takes to execute the R code in this document until the end:
```{r time_0}
t0 <- proc.time()
```


# Statistical model

Let's take the example of a perennial species:

* $I$: number of genotypes

* $Q$: number of years of phenotyping

* $N = I \times Q$: number of phenotypic observations

Likelihood:

\[
\forall q \in \{1,\ldots,Q\}, i \in \{1,\ldots,I\}, \; y_{qi} = \beta_0 + \beta_q + g_i + \epsilon_{qi}
\]

with the $\beta$'s being modeled as fixed effects, $\boldsymbol{g} \sim \mathcal{N}(\boldsymbol{0}, \sigma_g^2 \text{Id}_I)$ and $\boldsymbol{\epsilon} \sim \mathcal{N}(\boldsymbol{0}, \sigma_\epsilon^2 \text{Id}_N)$

It can also be rewritten as $\boldsymbol{y} = X \boldsymbol{\beta} + Z \boldsymbol{g} + \boldsymbol{\epsilon}$ where $X$ and $Z$ are incidence matrices.

The main goal is to estimate the heritability $H^2 = \frac{\sigma_g^2}{\sigma_g^2 + \sigma_\^epsilon^2}$ and quantify its uncertainty.


# Simulate data

Set the seed:
```{r set_seed}
set.seed(1859)
```

Set the constants:
```{r set_constants}
I <- 200
Q <- 5
N <- I * Q
sigma.g <- 3
sigma.epsilon <- 3
sigma.g^2 / (sigma.g^2 + sigma.epsilon^2)
```

Simulate the explanatory and error variables:
```{r simul_var}
beta <- matrix(c(50, rmvnorm(n=1, mean=rep(0, Q-1), sigma=10 * diag(Q-1))))
g <- t(rmvnorm(n=1, mean=rep(0, I), sigma=sigma.g^2 * diag(I)))
epsilon <- t(rmvnorm(n=1, mean=rep(0, N), sigma=sigma.epsilon^2 * diag(N)))
```

Make a data frame with the appropriate structure:
```{r make_df}
geno.names <- sprintf("geno%03i", 1:I)
dat <- data.frame(geno=rep(geno.names, Q),
                  year=as.factor(rep(2010:(2010+Q-1), each=I)),
                  pheno=NA)
```

Make the incidence matrices:
```{r}
X <- model.matrix(~ 1 + year, data=dat)
Z <- model.matrix(~ -1 + geno, data=dat)
```

Make the phenotypes and fill the data frame:
```{r}
y <- X %*% matrix(beta) + Z %*% matrix(g) + epsilon
dat$pheno <- c(y)
str(dat)
```


# Inference

## With lme4

### Model fitting

```{r lmer_fit}
system.time(
    fit.lmer.g <- lmer(formula=pheno ~ 1 + (1|geno), data=dat, REML=TRUE))
system.time(
    fit.lmer.y.g <- lmer(formula=pheno ~ 1 + year + (1|geno), data=dat, REML=TRUE))
```

### Model comparison and selection

```{r lmer_select}
extractAIC(fit.lmer.g)
extractAIC(fit.lmer.y.g)
fit.lmer <- fit.lmer.y.g
```

### Diagnostics

```{r lmer_orga}
beta.hat.lmer <- fixef(fit.lmer)
g.hat.lmer <- ranef(fit.lmer, condVar=TRUE, drop=TRUE)$geno
var.g.hat.lmer <- setNames(attr(g.hat.lmer, "postVar"),
                           names(g.hat.lmer))
sigma.epsilon.hat.lmer <- as.data.frame(VarCorr(fit.lmer))[2, "sdcor"]
sigma.g.hat.lmer <- as.data.frame(VarCorr(fit.lmer))[1, "sdcor"]
fit.lmer.all <- cbind(dat,
                      cond.res=residuals(fit.lmer),
                      scl.cond.res=residuals(fit.lmer) / sigma(fit.lmer),
                      fitted=fitted(fit.lmer))
str(fit.lmer.all, give.attr=FALSE)
```

```{r lmer_check}
(low.bound.norm.95 <- qnorm(p=0.025, mean=0, sd=1, lower.tail=TRUE))
x.lim <- max(abs(fit.lmer.all$scl.cond.res), na.rm=TRUE)
plot(x=fit.lmer.all$scl.cond.res, y=fit.lmer.all$fitted, las=1,
     xlim=c(-x.lim, x.lim))
abline(v=0, lty=2)
abline(v=c(low.bound.norm.95, abs(low.bound.norm.95)), lty=3)
shapiro.test(fit.lmer.all$scl.cond.res)
qqnorm(y=fit.lmer.all$scl.cond.res, main="Normal Q-Q plot of scl.cond.res")
qqline(y=fit.lmer.all$scl.cond.res, col="red")
x.lim <- max(abs(g.hat.lmer))
par(mar=c(5,6,4,1))
plot(x=g.hat.lmer, y=1:length(g.hat.lmer),
     xlim=c(-x.lim, x.lim),
     yaxt="n", ylab="")
axis(side=2, at=1:length(g.hat.lmer), labels=names(g.hat.lmer),
     las=1)
abline(v=0, lty=2)
```

### Inference

```{r lmer_res}
summary(fit.lmer)
cbind(beta, beta.hat.lmer)
cor(g, g.hat.lmer)
c(sigma.epsilon, sigma.epsilon.hat.lmer)
c(sigma.g, sigma.g.hat.lmer)
system.time(
    prof <- profile(fitted=fit.lmer, signames=FALSE))
(ci.lmer <- confint(object=prof, level=0.95))
```

Confidence interval on heritability:

* see Table S2 from Bhatia et al (2014)

* how to implement the approach of Meyer and Houle (2013) with `lmer`?


## With INLA

### Model fitting

```{r inla_fit}
system.time(
    fit.inla.g <- inla(formula=pheno ~ 1 + f(geno, model="iid"),
                       family="gaussian", data=dat,
                       control.compute=list(waic=TRUE)))
system.time(
    fit.inla.y.g <- inla(formula=pheno ~ 1 + year + f(geno, model="iid"),
                         family="gaussian", data=dat,
                         control.compute=list(waic=TRUE)))
```

### Model comparison and selection

```{r inla_select}
c(fit.inla.g$waic$p.eff, fit.inla.g$waic$waic)
c(fit.inla.y.g$waic$p.eff, fit.inla.y.g$waic$waic)
fit.inla <- fit.inla.y.g
```

Posterior predictive checks: see Held, Schrödle and Rue (2010), and use `inla.pmarginal()`?

### Diagnostics

```{r inla_orga}
beta.hat.inla <- fit.inla$summary.fixed[,"mean"]
g.hat.inla <- setNames(fit.inla$summary.random$geno[,"mean"],
                       fit.inla$summary.random$geno[,"ID"])
sigma.epsilon.hat.inla <- 1 / sqrt(fit.inla$summary.hyperpar[1, "mean"])
sigma.g.hat.inla <- 1 / sqrt(fit.inla$summary.hyperpar[2, "mean"])
fit.inla.all <- cbind(dat,
                      fitted=fit.inla$summary.linear.predictor[,"mean"],
                      cond.res=NA,
                      scl.cond.res=NA)
fit.inla.all$cond.res <- dat$pheno - fit.inla.all$fitted
fit.inla.all$scl.cond.res <- fit.inla.all$cond.res / rep(sigma.g.hat.inla, N)
str(fit.inla.all, give.attr=FALSE)
```

```{r inla_check}
(low.bound.norm.95 <- qnorm(p=0.025, mean=0, sd=1, lower.tail=TRUE))
x.lim <- max(abs(fit.inla.all$scl.cond.res), na.rm=TRUE)
plot(x=fit.inla.all$scl.cond.res, y=fit.inla.all$fitted, las=1,
     xlim=c(-x.lim, x.lim))
abline(v=0, lty=2)
abline(v=c(low.bound.norm.95, abs(low.bound.norm.95)), lty=3)
shapiro.test(fit.inla.all$scl.cond.res)
qqnorm(y=fit.inla.all$scl.cond.res, main="Normal Q-Q plot of scl.cond.res")
qqline(y=fit.inla.all$scl.cond.res, col="red")
x.lim <- max(abs(g.hat.inla))
par(mar=c(5,6,4,1))
plot(x=g.hat.inla, y=1:length(g.hat.inla),
     xlim=c(-x.lim, x.lim),
     yaxt="n", ylab="")
axis(side=2, at=1:length(g.hat.inla), labels=names(g.hat.inla),
     las=1)
abline(v=0, lty=2)
```

### Inference

```{r inla_res}
summary(fit.inla)
cbind(beta, beta.hat.inla)
cor(g, g.hat.inla)
c(sigma.epsilon, sigma.epsilon.hat.inla)
c(sigma.g, sigma.g.hat.inla)
```

TODO: understand how AnimalINLA provides intervals for heritability


## With MCMCglmm

TODO, but potentially much slower



# Appendix

```{r info}
t1 <- proc.time(); t1 - t0
print(sessionInfo(), locale=FALSE)
```
