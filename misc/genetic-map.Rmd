---
title: "Genetic map"
author: "Timoth√©e Flutre (INRA)"
date: "`r format(Sys.time(), '%d/%m/%Y %H:%M:%S')`"
colorlinks: true
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: TRUE
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: TRUE
urlcolor: blue
---

<!--
This R chunk is used to set up some options.
-->
```{r setup, include=FALSE}
R.v.maj <- as.numeric(R.version$major)
R.v.min.1 <- as.numeric(strsplit(R.version$minor, "\\.")[[1]][1])
if(R.v.maj < 2 || (R.v.maj == 2 && R.v.min.1 < 15))
  stop("requires R >= 2.15", call.=FALSE)

suppressPackageStartupMessages(library(knitr))
opts_chunk$set(echo=TRUE, warning=TRUE, message=TRUE, cache=FALSE, fig.align="center")
```


# Overview

This document requires external packages to be available:
```{r load_pkg}
suppressPackageStartupMessages(library(rutilstimflutre))
suppressPackageStartupMessages(library(scrm))
suppressPackageStartupMessages(library(ASMap))
stopifnot(file.exists(Sys.which("carthagene")))
```

This R chunk is used to assess how much time it takes to execute the R code in this document until the end:
```{r time_0}
t0 <- proc.time()
```


# Simulate genetic data at HWE

Set the seed:
```{r, set_seed}
set.seed(1859)
```

<!--
Simulate haplotypes and genotypes in a single population with a bottleneck:
```{r simul_haplos_genos}
nb.genos <- 1*10^3
nb.chrs <- 2
chrom.len <- 1*10^6     # in base pairs
mu <- 10^(-8)           # neutral mutation rate in events / base / generation
u <- mu * chrom.len     #  in events / chrom / gen
c.rec <- 10^(-8)        # recomb rate in events / base / gen
r <- c.rec * chrom.len  #  in events / chrom / gen
##                             _____
##                            /
##       ____________________/      Nec
##                       _Neb_
##                       |    \_____
##            Nea        |
##                       |
##                       |
##       ________________|
##                       2   1      0
## time  <---------------+---+------+
Nea <- 5 * 10^4         # ancestral
Neb <- 10 * 10^2        # bottleneck
Nec <- Ne0 <- 5 * 10^3  # current
theta <- 4 * Ne0 * u    # scaled neutral mutation rate in events / chrom
rho <- 4 * Ne0 * r      # scaled recomb rate in events / chrom
T1 <- 8000
T2 <- T1 + 2000
alpha <- - (4 * Ne0) / T1 * log(Neb / Ne0) # exp growth rate from Nec to Neb
cmd <- paste0("-eG ", T1/(4*Ne0), " ", alpha,
              " -eN ", T2/(4*Ne0), " ", Nea/Ne0)
genomes <- simulCoalescent(nb.inds=nb.genos,
                           nb.reps=nb.chrs,
                           pop.mut.rate=theta,
                           pop.recomb.rate=rho,
                           chrom.len=chrom.len,
                           other=cmd,
                           get.alleles=TRUE)
afs.pop <- estimSnpAf(X=genomes$genos)
mafs.pop <- estimSnpMaf(afs=afs.pop)
```
-->

Simulate haplotypes and genotypes in two populations:
```{r}
nb.genos <- 1*10^3
nb.chrs <- 2
chrom.len <- 1*10^6     # in base pairs
mu <- 10^(-8)           # neutral mutation rate in events / base / generation
u <- mu * chrom.len     #  in events / chrom / gen
c.rec <- 10^(-8)        # recomb rate in events / base / gen
r <- c.rec * chrom.len  #  in events / chrom / gen
m <- 2*10^(-5)          # migration rate in events / gen
Ne <- 10^4
theta <- 4 * Ne * u     # scaled neutral mutation rate in events / chrom
rho <- 4 * Ne * r       # scaled recomb rate in events / chrom
M <- 4 * Ne * m         # scaled migration rate in events
genomes <- simulCoalescent(nb.inds=nb.genos,
                           nb.reps=nb.chrs,
                           pop.mut.rate=theta,
                           pop.recomb.rate=rho,
                           chrom.len=chrom.len,
                           nb.pops=2,
                           mig.rate=M,
                           get.alleles=TRUE)
table(inds.per.pop <- kmeans(genomes$genos, 2)$cluster)
afs.pop <- estimSnpAf(X=genomes$genos)
mafs.pop <- estimSnpMaf(afs=afs.pop)
```

Look at some visual checks:
```{r}
plotHistAllelFreq(afs=afs.pop, main="Allele frequencies")
plotHistMinAllelFreq(mafs=mafs.pop, main="Minor allele frequencies")
A.vr.pop <- estimGenRel(X=genomes$genos, afs=afs.pop, method="vanraden1")
imageWithScale(A.vr.pop, main="Additive genetic relationships")
summary(diag(A.vr.pop))
hist(diag(A.vr.pop), col="grey", border="white")
summary(A.vr.pop[upper.tri(A.vr.pop)])
hist(A.vr.pop[upper.tri(A.vr.pop)], col="grey", border="white")
```


# Perform controlled crosses

Choose two individuals as parents (one per population):
```{r, choose_parents}
(idx.parents <- c(sample(x=names(inds.per.pop)[inds.per.pop == 1], size=1),
                  sample(x=names(inds.per.pop)[inds.per.pop == 2], size=1)))
genos.parents <- genomes$genos[idx.parents,]
names.parents <- rownames(genos.parents)
haplos.parents <- getHaplosInds(haplos=genomes$haplos,
                                ind.names=names.parents)
```

Cross them several times to make offsprings:
```{r, crosse_to_make_offsprings}
nb.offs <- 200
names.offs <- paste0("off-",
                     sprintf(fmt=paste0("%0", floor(log10(nb.offs))+1, "i"),
                             1:nb.offs))
head(crosses.off <- data.frame(parent1=rep(names.parents[1], nb.offs),
                               parent2=rep(names.parents[2], nb.offs),
                               child=names.offs,
                               stringsAsFactors=FALSE))
loc.crovers.off <- drawLocCrossovers(crosses=crosses.off,
                                     nb.snps=sapply(haplos.parents, ncol),
                                     simplistic=FALSE,
                                     verbose=1)
haplos.offs <- makeCrosses(haplos=haplos.parents, crosses=crosses.off,
                           loc.crossovers=loc.crovers.off,
                           howto.start.haplo=0)
genos.offs <- segSites2allDoses(seg.sites=haplos.offs,
                                ind.ids=getIndNamesFromHaplos(haplos.offs),
                                snp.ids=rownames(genomes$snp.coords))
```

Plot pedigree:
```{r, plot_ped}
ped <- data.frame(ind=c(names.parents,
                        crosses.off$child),
                  mother=c(rep(NA, length(names.parents)),
                           crosses.off$parent1),
                  father=c(rep(NA, length(names.parents)),
                           crosses.off$parent2),
                  gen=c(rep(0, length(names.parents)),
                        rep(1, nrow(crosses.off))),
                  stringsAsFactors=FALSE)
ped.tmp <- rbind(ped[1:7,],
                 c(ind="off-..", ped[7, -1]),
                 c(ind="off-...", ped[7, -1]),
                 c(ind="off-....", ped[7, -1]),
                 ped[nrow(ped),])
plotPedigree(inds=ped.tmp$ind, mothers=ped.tmp$mother, fathers=ped.tmp$father,
             generations=ped.tmp$gen, main="Pedigree of the controlled crosses")
```

Check additive genetic relationships:
```{r, add_gen_rel}
A.vr.cross <- estimGenRel(X=rbind(genos.parents, genos.offs),
                          afs=afs.pop, method="vanraden1")
A.t.cross <- estimGenRel(X=rbind(genos.parents, genos.offs),
                         afs=afs.pop, method="toro2011_eq10")
cor(c(A.vr.cross), c(A.t.cross))
imageWithScale(A.vr.cross, main="Additive genetic relationships of crosses")
imageWithScale(A.vr.cross[1:10, 1:10],
               main="Additive genetic relationships of crosses (subset)",
               idx.rownames=1:10, idx.colnames=1:10)
summary(diag(A.vr.cross))
summary(A.vr.cross[upper.tri(A.vr.cross)])
summary(A.vr.cross[names.parents[1], grep("off", colnames(A.vr.cross))])
summary(A.vr.cross[names.parents[2], grep("off", colnames(A.vr.cross))])
summary(A.t.cross[names.parents[1], grep("off", colnames(A.t.cross))])
summary(A.t.cross[names.parents[2], grep("off", colnames(A.t.cross))])
```

Under HWE in a single population, the additive genetic relationships between all parent-child pairs should be centered around 0.5, corresponding to a coancestry coefficient of 1/4.


# Build genetic map with CarthaGene

Prepare the input data:
```{r}
genos.doses <- cbind(t(genos.parents), t(genos.offs))
genos.classes <- genoDoses2genoClasses(tX=genos.doses,
                                       alleles=genomes$alleles)
genos.jm <- genoClasses2JoinMap(genos.classes)
genos.cg <- joinMap2CarthaGene(genos.jm[, -c(1:8)])
sapply(genos.cg, dim)
file.par1 <- "genos_carthagene_parent1.txt"
writeCartagene(genos.cg$parent1, file.par1)
```

Load the data set:
```{r}
cg <- openCarthagene(file.par1)
(out <- runCarthagene(cg, "cgversion"))
(out <- runCarthagene(cg, "dsinfo"))
out.mrkinfo <- runCarthagene(cg, "mrkinfo")
dim(mrk.info <- parseCgMrkinfo(out.mrkinfo))
(out <- runCarthagene(cg, "heapsizeget"))
```

Determine the linkage groups:
```{r}
cmd <- "group 0.3 3" # params chosen by trial and error
out.group <- runCarthagene(cg, cmd)
linkgroups <- parseCgGroup(out.group, mrk.info)
sapply(linkgroups, nrow)
head(linkgroups[[1]])
```

Check that all markers put in the same linkage group belong to the same chromosome:
```{r}
sapply(linkgroups, function(lg){
  table(genomes$snp.coords[gsub("_m", "", lg$name), "chr"])
})
```

Determine the marker order for the first group (by building a framework map):
```{r}
runCarthagene(cg, "mrkselset [groupget 1]")
system.time(
    out.buildfw <- runCarthagene(cg, "buildfw 3 3 {} 1")) # 2400 sec = 40 min
```

Check its reliability:
```{r}
system.time(
    out.flips <- runCarthagene(cg, "flips 4 3 0"))
out.flips
```

Get the maps (best is last):
```{r}
out.heaprint <- runCarthagene(cg, "heaprint")
out.bestprint <- runCarthagene(cg, "bestprint")
out.bestprintd <- runCarthagene(cg, "bestprintd")
```

TODO: parse the output of bestprintd

Save CarthaGene's state:
```{r}
file.cgsave <- "cgsave.tcl"
(out <- runCarthagene(cg, paste("cgsave", file.cgsave)))
file.export <- "cg_map.txt"
(out <- runCarthagene(cg, paste("cgexport", file.export,
                                "FruitSelgen_SxG", "chr2")))
```

Clean:
```{r}
closeCarthagene(cg)
```


# Build genetic map with ASMap

Prepare the input data:
```{r}
genos.doses <- cbind(t(genos.parents), t(genos.offs))
dim(tX <- genos.doses[estimSnpMaf(t(genos.doses[,-(1:2)])) > 0.15,])
genos.asmap <- genoDoses2ASMap(tX=tX)
sapply(genos.asmap, dim)
```

Build the map:
```{r}
system.time(
    map.par1 <- mstmap(genos.asmap$parent1,
                       pop.type="BC",
                       dist.fun="kosambi",
                       objective.fun="COUNT",
                       p.value=10^(-6), # proba below which markers are in same group
                       miss.thresh=1,
                       as.cross=TRUE))
```

```{r, eval=TRUE}
plot.map(map.par1)
heatMap(map.par1)
```

```{r, eval=TRUE}
profileMark(map.par1, crit.val="bonf")
```

```{r, eval=TRUE}
clones <- genClones(map.par1)
clones$cgd
(pair1 <- c(as.character(clones$cgd[1,1]),
            as.character(clones$cgd[1,2])))
A.vr.cross[pair1, pair1]
loc.crovers.off[[pair1[1]]]
loc.crovers.off[[pair1[2]]]
idx <- grep(paste(pair1, collapse="|"), rownames(haplos.offs$chr1))
plotHaplosMatrix(haplos.offs$chr1[idx[c(1,3,2,4)],], main="Haplotypes (chr1)")
plotHaplosMatrix(haplos.offs$chr2[idx[c(1,3,2,4)],], main="Haplotypes (chr2)")
```

```{r, eval=FALSE}
map.c <- combineMap(map.par1, map.par2)
```


# Appendix

```{r info}
t1 <- proc.time(); t1 - t0
print(sessionInfo(), locale=FALSE)
```
