% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantgen.R
\name{lmerAM}
\alias{lmerAM}
\title{Animal model}
\usage{
lmerAM(formula, dat, relmat, REML = TRUE, ci.meth = NULL, verbose = 1)
}
\arguments{
\item{formula}{formula (see \code{\link[lme4]{lmer}})}

\item{dat}{data.frame containing the data corresponding to formula and relmat (see \code{\link[lme4]{lmer}})}

\item{relmat}{list containing the matrices of genetic relationships (A is compulsory but D is optional); should use the same names as the colnames in data; can be in the "matrix" class (base) or the "dsCMatrix" class (Matrix package); see \code{\link{estimGenRel}}}

\item{REML}{default is TRUE (use FALSE to compare models with different fixed effects)}

\item{ci.meth}{method to compute confidence intervals (profile/boot); if not NULL, use \code{\link[lme4]{confint.merMod}}}

\item{verbose}{verbosity level (0/1)}
}
\value{
list which first component is a \code{\link[lme4]{merMod}} object and second component a data.frame with confidence intervals (if ci.meth is not NULL)
}
\description{
Given I genotypes, Q covariates and N=I*Q phenotypes for the trait, fit an "animal model" with the lme4 package via the following likelihood: y = W c + Z g_A + Z g_D + epsilon, where y is Nx1; W is NxQ; Z is NxI; g_A ~ Normal_I(0, sigma_A^2 A) with A the known matrix of additive genetic relationships; g_D ~ Normal_I(0, sigma_D^2 D) with D the known matrix of dominant genetic relationships; epsilon ~ Normal_N(0, sigma^2 Id_N); Cov(g_A,g_D)=0; Cov(g_A,e)=0; Cov(g_D,e)=0.
}
\note{
If A is not positive definite, an error will be raised (via \code{\link[base]{chol}}); in such cases, using the nearPD function from the Matrix package can be useful.
}
\examples{
## simulate genotypes
set.seed(1859)
I <- 100 # genotypes
P <- 2000 # SNPs
X <- matrix(sample(0:2, size=I*P, replace=TRUE), nrow=I, ncol=P,
            dimnames=list(paste0("geno", 1:I), paste0("snp", 1:P)))

## simulate phenotypes with only additive part of genotypic values
A <- estimGenRel(X, relationships="additive", method="vanraden1", verbose=0)
A <- as.matrix(Matrix::nearPD(A)$mat) # not always necessary
modelA <- simulAnimalModel(T=1, Q=3, A=A, V.G.A=15, V.E=5)

## infer with lme4
fitA <- lmerAM(formula=response1 ~ year + (1|geno), dat=modelA$dat,
               relmat=list(geno=A), verbose=0)
summary(fitA$merMod)
REMLcrit(fitA$merMod)
extractAIC(fitA$merMod)
summary(residuals(fitA$merMod)) # "deviance residuals"
summary(residuals(fitA$merMod) / sigma(fitA$merMod)) # "scaled/Pearson residuals"
c(modelA$C); modelA$V.G.A; modelA$V.E
fixef(fitA$merMod)
vc <- as.data.frame(VarCorr(fitA$merMod))
c(vc[vc$grp == "geno", "vcov"], vc[vc$grp == "Residual", "vcov"])
blups.geno <- ranef(fitA$merMod, condVar=TRUE, drop=TRUE)$geno
var.blups.geno <- setNames(attr(blups.geno, "postVar"), names(blups.geno))

## simulate phenotypes with additive and dominant parts of genotypic values
D <- estimGenRel(X, relationships="dominant", method="vitezica", verbose=0)
D <- as.matrix(Matrix::nearPD(D)$mat) # not always necessary
modelAD <- simulAnimalModel(T=1, Q=3, A=A, V.G.A=15, V.E=5,
                            D=D, V.G.D=3)

## infer with lme4
modelAD$dat$geno.add <- modelAD$dat$geno
modelAD$dat$geno.dom <- modelAD$dat$geno; modelAD$dat$geno <- NULL
fitAD <- lmerAM(formula=response1 ~ year + (1|geno.add) + (1|geno.dom),
                dat=modelAD$dat, relmat=list(geno.add=A, geno.dom=D),
                verbose=0)
summary(fitAD$merMod)
c(modelAD$C); modelAD$V.G.A; modelAD$V.E; modelAD$V.G.D
fixef(fitAD$merMod)
vc <- as.data.frame(VarCorr(fitAD$merMod))
c(vc[vc$grp == "geno.add", "vcov"], vc[vc$grp == "Residual", "vcov"],
  vc[vc$grp == "geno.dom", "vcov"])
}
\author{
Timothee Flutre (inspired by Ben Bolker at http://stackoverflow.com/q/19327088/597069)
}
\seealso{
\code{\link{inlaAM}}, \code{\link{jagsAM}}
}

